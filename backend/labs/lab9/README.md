# Лабораторна робота №9: Виправлення ботлнеків та рефакторинг

## Зміст
1. [Аналіз вразливих модулів](#1-аналіз-вразливих-модулів)
2. [Рефакторинг модуля та винос в бібліотеку](#2-рефакторинг-модуля-та-винос-в-бібліотеку)
3. [Тестування після рефакторингу](#3-тестування-після-рефакторингу)
4. [Висновок](#4-висновок)

---

## 1. Аналіз вразливих модулів

**Ціль:** Визначити модулі системи, які найбільше впливають на продуктивність, та проаналізувати їхній дизайн для подальшого рефакторингу.

### **Результати аналізу:**
- **Метод:** Використано результати профілювання сервера з попередньої роботи.
- **Основні проблеми:**
  1. Запити до бази даних мали високі затримки, що впливало на загальну продуктивність.
  2. Багато модулів мали неефективний дизайн, зокрема тісно переплетену бізнес-логіку з логікою доступу до даних.
  3. Відсутність чіткої типізації та структуризації коду ускладнювала подальшу розробку та підтримку.
  4. Прямий доступ до бази даних без абстракцій збільшував ризик помилок.

#### **Основні проблеми:**
1. **Запити до бази даних:** Некоректно виконувались запити через відсутність індексації, що спричиняло уповільнення операцій.
2. **Дизайн:** Відсутність чіткого поділу на модулі, що ускладнювало тестування.
3. **Асинхронність:** Некоректне використання асинхронних функцій призводило до блокування event loop.
4. **Типізація:** Відсутність статичної типізації робила код більш схильним до помилок.

#### **Рекомендації:**
1. Абстрагувати доступ до бази даних через окремі модулі для забезпечення кращого тестування.
2. Використати TypeScript для покращення типізації та структурування коду, що дозволить зменшити кількість помилок і підвищити якість коду.

---

## 2. Рефакторинг модуля та винос в бібліотеку

### **Процес:**
1. **Перехід на TypeScript:** Уся backend частина була переписана на TypeScript. Тепер весь код знаходиться в каталозі `src`, а після компіляції — в каталозі `dist`.
2. **Розділення логіки:** Модулі були реорганізовані для чіткого розділення бізнес-логіки та логіки доступу до даних.
   - Наприклад модуль доступу до користувачів (`userModel`) було переписано в окремий клас `UserModel` у файлі `src/db/userModel.ts`(../../src/db/userModel.ts).
   - Для кожного модуля було створено окремі файли, що дозволяє зменшити зв'язність між компонентами.
   - Інтерфейси були додані для всіх основних компонентів, що дозволило забезпечити чітку типізацію та зменшити кількість помилок.
3. **Оптимізація запитів:** Запити до бази даних були оптимізовані за рахунок індексації таблиць та використання параметризованих запитів для запобігання SQL-ін'єкціям.
4. **Покращена типізація:** Завдяки використанню TypeScript, стало можливим виявлення помилок на етапі компіляції, що значно підвищило стабільність та якість коду.

#### **Ключові зміни:**
- Весь backend код переписано на TypeScript.
- Всі файли тепер знаходяться в папці `src`, а після компіляції код потрапляє в `dist`.
- Було видалено `.js` файли, а замість них створено TypeScript модулі такі як:
  - `src/db/database.ts`: Реалізація модуля для роботи з базою даних.
  - `src/db/userModel.ts`: Модель доступу до користувачів (також інші моделі).
  - `src/routes/users.ts`: Модуль для роботи з API користувачів.
  - `src/utils/generateCode.ts`: Утиліта для генерації коду та інші.

#### **Детальний опис нових файлів:**
- **`src/db/database.ts`:**
  - Містить класи для роботи з користувачами та іншими даними.
  - Інкапсулює запити до бази даних через методи `getUserByLogin`, `createUser`, що забезпечує чітке розділення логіки.

- **`src/routes/users.ts`:**
  - Реалізація API для роботи з користувачами. Використовує новий рефакторизований код для доступу до бази даних.

#### **Приклад коду після рефакторингу:**
```typescript
import { db } from './database.js';

type User = {
  id?: number; 
  login: string;
  email: string;
  password: string;
};

function addUser(user: Omit<User, 'id'>, callback: (err: Error | null, result?: any) => void): void {
  const { login, email, password } = user;
  const stmt = db.prepare(
    'INSERT INTO users (login, email, password) VALUES (?, ?, ?)',
  );
  stmt.run([login, email, password], function (err) {
    callback(err, { id: this.lastID, ...user }); 
  });
  stmt.finalize();
}
```

---

## 3. Тестування після рефакторингу

**Ціль:** Перевірити працездатність та продуктивність рефакторизованого модуля.

### **Процес тестування:**
1. **Функціональні тести:** Перевірено основні сценарії використання модуля.
2. **Навантажувальне тестування:** Виконано тестування з використанням k6.
3. **Профілювання:** Проведено аналіз продуктивності за допомогою Clinic.js.

### **Результати:**
- **Функціональні тести:** Усі сценарії успішно виконані.
- **Навантажувальне тестування:**
  - Середній час відповіді зменшився з 892.86 мс до 523.12 мс.
  - Максимальний час відповіді зменшився з 3.03 с до 1.84 с.
- **Профілювання:** Зменшено використання ресурсів серверу на 25% завдяки оптимізації запитів та зменшенню навантаження на event loop.

### **Звіти тестування:**
1. **k6:** Скріншот з результатами:
   ![k6 results](k6.png)
2. **Clinic.js:** Скріншот з результатами:
   ![Clinic.js Flame](clinic.png)

---

## 4. Висновок

1. **Оптимізація:**
   - Перехід на TypeScript дозволив значно зменшити кількість помилок на етапі розробки та полегшити підтримку проекту.
   - Оптимізація запитів до бази даних зменшила навантаження на сервер та підвищила продуктивність.

2. **Продуктивність:**
   - Час виконання основних запитів значно скоротився завдяки кращій оптимізації та рефакторингу.
   - Система стала більш масштабованою та стійкою до навантажень.

3. **Рекомендації:**
   - Продовжити використання TypeScript у всьому проекті для підтримки високої якості коду.
   - Регулярно виконувати профілювання та навантажувальні тести для пошуку нових ботлнеків.

---

Рефакторинг коду на TypeScript покращив стабільність, продуктивність і зручність підтримки backend частини проекту, значно знизивши ймовірність помилок і підвищивши ефективність роботи системи.